<!DOCTYPE html>
<html lang="en">

<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta name="author" content="Mark Tobler">
   <meta name="description" content="Week 3 Notes for WDD330">
   <link rel="stylesheet" href="../week02/styles/wdd_week02.css" </head>

<body>
   <nav>
      <div><a href="../index.html">&laquo;</a></div>
   </nav>
   <header>
   </header>
   <main>
      <h1>Week 3</h1>
      <div class="toc" id="toc"></div>
      <!--the toc will contain all h3's in a file. The collapsible portion of 
         sections will be the contained article. Both (menu and collapsible 
         functionality) need an h3 somewhere in the section to be included. 
         There is no restriction on the order or whether the article is a 
         sibling or child of the h3 or vice-versa, just a h3 and an article. 
         Clicking or tapping the h3 is the triggering event -->
      <div class='note x-small'>(new subtopic jump to menu - built dynamically out of JS.)
         <br>(also, subtopics are now collapsible.)</div>
      <section>                  
         <!-- <div> -->
            <h3>
               + Falsey Values in JS
            </h3>
            <div>
            <article>               
               <div class="note">This topic is self directed exploration. Citations provided where appropriate.</div>
               <!-- </div>
         <div class='collapsible'> -->
               Some notes to clear up any confusion on the rogue types, objects and primitives that are falsey.
               <br /><br />
               <div class="accent_1 big fullbar">First, review: == and ===</div>
               <br />
               == <note>loose equality opertor: (also ternary operator: ?)</note>
               <br />
               checks for the truthiness of an expression by value. Type may be coerced, i.e., may be evaluated as a different type:
               <br />
               <br />
               === <note>strict equality:</note>
               <br />
               checks for equality by value and type.
               <br />
               <br />
               <br />
               <div class="accent_2 big fullbar">undefined <note>primitive, a type; falsey!</note>
               </div>
               <div class='explanation'>
                  Indicates an identifier is declared but not initialized, no value.
                  <br />
                  Non-existent object properties will be undefined, making it possible to check if an object has a property(attribute):<br /></div>
               <!-- <note>Great for checking if a class has a property</note> -->
               <div class='accent_1'><code>superman.city !== undefined;<br>
                  << false</code></note>
               </div>
               <br />
               Equality for undefined:
               <br />
               <div class="code">
                  typeof(undefined); //"undefined"
                  <br />
                  x = undefined; y = undefined;
                  <br />
                  (x == y) == true; (x === y) === true;
                  <br />
                  //!! Important. undeclared array elements == and === eachother:
                  <br />
                  arr = [];
                  <br />
                  arr[0] == arr[1] == true; arr[0] === arr[1] == true;
                  <br />
               </div>
               <br />
               Boolean value:
               <br />
               <div class="code">
                  // undefined is neither true or false:
                  <br />
                  !undefined == true == true; undefined == true == false;
               </div>
               <br />
               Compares to null:
               <br />
               <div class="code">
                  undefined == null == true;
                  <br />
                  undefined === null == false; null !== undefined == true;
                  <br />
               </div>
               Math:

               <br />
               <div class="code">
                  Number(undefined) == NaN
               </div>
               <br />
               <div class="accent_2 big fullbar">null</div>
               <div class='explanation'>
                  <note>object; falsey!</note>
                  <br />
                  In JS/ES6 null is an assignable object meaning 'no value'/'nothing.'
                  <br />
                  There is only one null. All null items resolve to the same null object.
               </div>
               <br />
               Equality of null:
               <br />
               <div class="code">
                  typeof(null); // "object"
                  <br />
                  x = null; y = null;
                  <br />
                  (x == y) == true; (x === y) === true;
               </div>
               <br />
               Boolean value:
               <br />
               <div class="code">
                  // null is neither true or false:
                  <br />
                  !null == true == true; null == true == false;
                  <br />
               </div>
               Compares to undefined:
               <br />
               <div class="code">
                  null == undefined == true;
                  <br />
                  null === undefined == false;
                  <br />
                  !null === !undefined == true; (falsey!! consider order of operations:
                  <br />
                  (!null) === (!undefined) == true; (same expressions)
               </div>
               <br />
               Math:
               <div class="code">
                  <br />
                  Number(null) == 0; // null converts to 0 in math operations.
               </div>
               <br />
               <div class="accent_2 big fullbar">NaN </div>
               <div class='explanation'>
                  <div class='note'> number; falsey!</div>

                  Acronym for "Not a Number".
                  <br />
                  consider:

                  <div class="code">'running' - 3;</div>
                  where running is the idea of running, i.e., to ambulate quickly.
                  <br />
                  NaN: can't consistently|logically derive number from expression.
               </div>
               <note>Caution using String NaNs and addition&mdash;will convert to String</note>:
               <br />
               <div class="code">
                  'running' + 3 == 'running3';
                  <br />
                  true + 'false' == 'truefalse';
                  <br />
               </div>
               Boolean expressions will evaluate to false:
               <br />
               <div class="code">
                  !NaN == true; (falsey!!!)
                  <br />
                  NaN == NaN == false; NaN === NaN == false;
                  <br />
                  //SO USE isNaN():
                  <br />
                  isNaN(NaN) == true;
                  <br />
               </div>
               Number and boolean operations convert bool to 1 (true) or 0 (false):
               <br />
               <div class="code">
                  true + 1 == 2;
                  <br />
                  false - 2 == -2;
                  <br />
                  true / false == Infinity;
                  <br />
               </div>
               <br />
               <div class="accent_2 big fullbar">' ' <span class="color_bg_2">(empty string)</span></div>
               <div class='explanation'>
                  <note>?</note><br />You're getting pretty good at this. Is it falsey or truthy?
               </div>
               <div class="code">
                  '' ? console.log('truthy') : console.log('falsey');
               </div>
               <div id="isTruthy_result_strNull"></div><button class='btn' data-symbol='strNull'>run</button>
               <br />
               <br />
               <note>Others not covered in depth: 0, 0n, false; but basically:
                  <br />
                  these falsey values loosely equal each other using ==, at least:
               </note>
               <br />
               <div class="code">
                  0==0n==false==""; // note the empty string.
                  <br />
                  null==undefined;
                  <br />
                  // remember NaN does not equal anything, not even itself: use isNaN()
               </div>
               <br />
               <div class="fullbar big accent_1"> Infinity</div>
               <note> number</note>
               <div class="code">Infinity<br />Number.POSITIVE_INFINITY<br /> Number.NEGATIVE_INFINITY</div>
               <br />
               But is it falsey?<note>Run this ternary expression to see:</note>
               <div class="code">Infinity ? 'truthy':'falsey'; </div>
               <div id="isTruthy_result_Infinity"></div><button class='btn' data-symbol='Infinity'>run</button>


               <br /><br />
               <div class="explanation">Any math operation that would cause a buffer overrun is assigned the global property: infinity. Anything larger than
                  Number.MAX_SAFE_INTEGER: (2^53
                  - 1) or 9007199254740991 or 1.79e+308</div>
               <br />
               <note>Watch out for:</note>
               <br />
               When dividing by 0, sigFault will not occur, Infinity will be used instead. Any further boolean expressions will likely fail to produce intended
               results:
               <br />
               <div class="code">
                  x = 1/0;
                  <br />
                  x + 1
                  < x + 2; // false <br />
                  x + 1 === x + 2; // true
                  <br />
                  2 * Infinity == 2 + Infinity
               </div>
               <div class="accent_2">
                  <code>Use Number.isFinite()</code> to get around this.
               </div>
               <div class="explanation">
                  Remember, <code>isFinite()</code> is different from <code>Number.isFinite()</code>. First function is part of the global object and uses
                  coercion.
                  <br />
               </div>
            </article>
         </div>
         <!-- </div> -->
      </section>
      <section>
         <h3>Team Activity</h3>
         <article>
         <note>View using &quot;View Page Source&quot; and the browser console.</note><br />
         <a href="team03.html">Fun with array methods</a>
         </article>
      </section>
      <section>
         <h3>Fun with Objects</h3>
      <article>
         <div class="explanation">
            <ul>
            <li>JS is prototypal, not classical (prototyped, not class-based)</li>
            <li>JS has no real concept of classes, only objects.
               <br>(<code>class</code> keyword is &quot;syntactical sugar&quot; in ES6)</li>
               <li>MUTABLE at any time even if const'd.</li>
         </ul>            
         </div>
         <!-- <pre>             -->
            <div class="fullbar big accent_1">OBJECT LITERALS</div>
            <pre>
         <div class='explanation'>
defined using { };
contain:
   key:value pairs (properties)
   functions (methods)
   accessible using:
         . notation
         [] notation      
Ex:
</div><div class="code-pre">
const superman = {
   name: 'Superman',
   'real name': 'Clark Kent',
   height: 75,
   weight: 235,
   hero: true,
   villain: false,
   allies: ['Batman','Supergirl','Superboy'],
   fly() {
      return 'Up, up and away!';
   }
};
// note the 'real name' key. Keys quoted only if non-conforming.
// note the fly() method invocation:
superman.fly();
superman['fly']();
superman['real' + ' ' + 'name'];
// or just
superman['real name']
// note non-existent properties are
superman.lie();   // undefined
// add a computed property
superman.BMI = superman.weight / superman.height;
// keys can be computed too:
superman['home' + 'Planet'] = 'Krypton';
log(superman.homePlanet); // Krypton
</div>      
      </pre>
<div class="fullbar big accent_1">Finding an object's UNIQUE PROPERTIES:</div>
<notes>
- rather than iterate over through properties using 'in' operator,
   the follow methods are part of the Object superclass:</notes>      
<div class="code-pre" >Object.keys(obj) // returns [keys...]
Object.values(obj) // returns [values...]
Object.entries(obj) // returns [key:values...]</div> 
      <notes>
-deleting properties, methods:
   - simply use delete:
   </notes>
<div class="code-pre" >delete someObj.propToBeDeleted;</div> 
<notes>- can be done for methods:
</notes>
<div class="code-pre" >delete someObj.methodToBeDeleted; // leave off the ()
</div> <notes>
-Nested Objects:
   - simply add them using the key:value syntax, Ex.:
</notes><div class="code-pre" >const obj = {
   name: 'object',
   nestObj: { name: 'nested object'},
   anthrNestedObj: { name: 'another nested object' }
}; // note the absence of a ';' inside the object.
   // a final ',' is accepted, although I don't know if it
   // has any effect.
</div> <notes>
   - access them the same way through .notation:</notes>
<div class="code-pre" >obj.nestObj.name
// or
obj['nestObj']['name']
// or mix
obj.nestObj['name']
</div> <notes>
-Object vars are POINTERS
   - assignment operator only assigns the address not the actual obj.
   - called &quot;by reference&quot; in JS.
-Objects make great function parameters/arguments:
   - kinda similar to tupples or dicts in python
      Ex.:</notes>
<div class="code-pre" >func = ({propertyName, anotherPropName, stillAnother})=&gt; {
   str = `Value of propertyName: ${propertyName}\n
            Value for anotherPropName: ${anotherPropName}\n
            Value for stillAnother: ${stillAnother}`;
   return str;
}; // note that the property names must match
         </div> <notes>
      - works with optional and default value arguments as well.
      - many restful APIs take an object sent via PUT
      </notes> 
<div class="fullbar big accent_2">OBJECT LITERAL PATTERN</div>
<notes>-Using objects as namespaces to get the same
effect as a module or library. Ex.:</notes>
<div class="code-pre" >const marksMethods = {
   log(str) {
      console.log(str);
   },
   repeat(str, times) {
      returnStr = '';
      for(i = 0; i &lt; times; i++)
         returnStr += (str + ' ');
      return returnStr;
   }
};
marksMethods.log('simple');
marksMethods.repeat('aloha' 3);</div> 
      
<div class="fullbar big accent_2">BUILT IN OBJs</div><notes>
JSON
   -Can be likened to the object literal with some differences:
      - Property names must be double-quoted
      - Permitted values are double-quoted strings, numbers,
            true, false, null, arrays and objects
      - Functions are not permitted values (they are simply ignored)
   -methods:
      parse(JsonStr) : Object
         - JsonStr must be in JSON format
      stringify(obj) : JSON formatted String
         - add a \n between key:value pairs like so:
            stringify(obj, null, ' ');
Math
   already familiar with the abs, ceil, floor, round, trunc methods
   pow, sqrt, max, min, sin, cos, tan, acos, atan (and sinh...)
   cbrt(n) is cuberoot
   random() as you like it. 0 to 1 (noninclusive) * by upper range
   hypot(n1, n2) : sqrt(pow(n1,2) + pow(n2,2)); pythagorean theorem

RegEx
   already decent with these: used /\s+/g in this weeks portfolio

IMPORTING &amp; EXPORTING:
type=&quot;module&quot; ambulate

NOTE: LOOK INTO the new Symbol primitive data type!
(Used as an identifier for object properties)?
</notes>
            ==============
</pre>
      </article>
      </section>
      <section>
         <h3>
            As promise last week, JSON formatting.
         </h3>
         <article>
            <notes>
Fetch is now part of standard JS/ES6.
Using it with spread operator:
Ex.:
const endPointURL = `https://jsonplaceholder.typicode.com/todos`;
const someArray = [];

fetch(endPointURL)
   .then(res =&gt; res.json())
   .then(data =&gt; someArray.push(...data))
   .catch(error =&gt; console.log(`learn errorhandling: ${error}`));

============
Next week spread vs destructuring
            </notes>
         </article>   
      </section>
      <section>
         <h3>
            MANIPULATING CSS VARIABLES WITH JS
         </h3>
         <article>
            <notes>            
Several things come together for this:
   1. Have the CSS variables somewhere accessible through the DOM.
   2. Some input method for user to indicate desired changes.
      - inputs' name match CSS variables' name
      - inputs store attributes prefixed with 'data-'
      - 'data-' attributes contain unit info, e.g., 'px', 'rem', etc...
         Ex.: <code>data-unit='px'</code>
   3. Adding 1+ events to listener on each input,
   4. listener fires a function.
   5. Function accesses #1,style.setProperty()
      - function uses `this` to access the input property dataset which contains all the 'data-' attributes from the input element in #2.
      Ex.:</notes>
<div class="code-pre">updateCSSVariable = () =&gt; {
   const unit = this.dataset.unit || '';
   document.documentElement
      .style.setProperty(--${this.name}`, 
                     this.value + unit);
}</div>
         </article>         
      </section>
   </main>
   <footer>
      &copy;2020 | Mark Tobler Portfolio | WDD 330
   </footer>
</body>
<script>
   // document.querySelector("#exe_infinity").addEventListener("click", isTruthy);
   document.querySelectorAll("button").forEach(butt => { butt.addEventListener("click", isTruthy); });
   document.querySelectorAll("section h3").forEach(sh3 => sh3.addEventListener("click", collapse));

   function collapse() {
      const _article = this.parentElement.querySelector('article');
      visibility = _article.style.display == 'none' ? 'initial' : 'none';
      _article.style.display = visibility;      
   }
   function isTruthy() {
      //alert(this.dataset.symbol);
      att = this.dataset.symbol;
      innerVal = '';
      truthDisplay = document.querySelector(`#isTruthy_result_${att}`);
      switch (att) {
         case 'Infinity':
            innerVal = Infinity ? 'truthy' : 'falsey';
            break;
         case 'strNull':
            innerVal = '' ? 'truthy' : 'falsey';
            break;
         default:
            innerVal = 'not configured =('
            break;
      }
      truthDisplay.innerHTML = innerVal;
      truthDisplay.style.color = 'var(--color_accent_2h)';
      this.style.display = 'none';
   };

   // I'm using an HTML formatting extension, and it keeps removing my spacing. I'll move my JS into a separate file starting week4.
   // using js to build a jump to select menu out of the h3 tagged elements.
   window.onload = () => {
      let js_toc = document.querySelector('#toc');
      let h3_list = document.querySelectorAll('h3');
      if (h3_list.length > 0) {
         let _ul = document.createElement("select");
         _ul.setAttribute("onchange", `document.getElementById(options[selectedIndex].value).scrollIntoView(true);`);
         _ul.innerText = `Topics: (dynamic list)`;
         js_toc.appendChild(_ul)
         let h_li = document.createElement("option");
         h_li.innerText = "Select from this week's topics:";
         _ul.appendChild(h_li);
         h3_list.forEach((e) => {
            h_li = document.createElement("option");
            h_li.innerText = e.innerText;
            let h_value = e.innerText.replace(/\s+/g, '_');
            e.setAttribute("id", h_value);
            // h_value = '#' + h_value;
            h_li.setAttribute("value", h_value);
            let h_a = document.createElement("a");
            h_a.setAttribute("href", h_value);
            _ul.appendChild(h_li);
            e.appendChild(h_a);
         });
      }
   };

</script>

</html>
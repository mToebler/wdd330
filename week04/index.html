<!DOCTYPE html>
<html lang="en">

<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta name="author" content="Mark Tobler">
   <meta name="description" content="Week 4 Notes for WDD330">
   <link rel="stylesheet" href="styles/wdd_week04.css">
   <script defer type="text/javascript" src="scripts/wdd_portfolio.js" charset="UTF-8"></script>
</head>
<body>
   <nav>
      <div><a href="../index.html" class="x-small">&laquo;Back</a></div>
      <h1>Week 4</h1>
      <div class="wrapper"><div class="toc" id="toc"></div>
            <!--the toc will contain all h3's in a file. The collapsible portion of 
         sections will be the contained article. Both (menu and collapsible 
         functionality) need an h3 somewhere in the section to be included. 
         There is no restriction on the order or whether the article is a 
         sibling or child of the h3 or vice-versa, just a h3 and an article. 
         Clicking or tapping the h3 is the triggering event -->
         <button class='btn_swap'>Toggle Dark/Light Modes</button>
      </div>
   </nav>
   <header>
   </header>
   <main>
        <section style="display:none">
            <h3>
               - SPREAD vs DECONSTRUCTION
            </h3>
            <article>
   <div class='article_bar accent_1'>Spread...</div>
   <!--notes are 'pre' white-spaced meaning spaces and CR's matter!!-->
   <notes>
   Body:
      <code class='big'>Try to follow the spacing</code> 
      <code class='big'>Looks better()</code>
   
   <note class='accent_2'>HOWEVER </note>, nothing in stone!
   
   <note class='accent_1'>EXPLORE </note>: that's what this is about.
   
   <div class='code'>
      code samples go here
   </div>
   
   </notes>
   <div class='article_bar accent_2'> Deconstruction...</div>
   <notes><note>(Inspired by <a href='https://javascript30.com/' target='_blank'>Wes Bos</a> ðŸ’ª)</note>
   
   
   Ex.:   
   </notes>
            </article>         
         </section>
         <section>
            <h3>
               + DOM STUFF
            </h3>
            <article>
   <div class='article_bar accent_1'>Query Selectors</div>
   <!--notes are 'pre' white-spaced meaning spaces and CR's matter!!-->
   <div class="explanation">This section is a bit messy in terms of formatting. I'm working on a function that formats the sections, but it isn't ready this week. However, I did dynamically move this section to the end using the getElementsByTagName(), appendChild() and [].forEach.call() methods - all very relavant to this sections material. </div>
   <notes>
Note: convention: use '$' at the beginning of a DOM variable identifier.

document.createElement('article').addChild('div');
Query Selectors
   document.querySelector('div');
   // !live (not live) like .getElementById() and it's getElement friends
   document.querySelectorALL('div');
   // returns div[] all divs, in order
 - the query selector methods use CSS selector syntax:
   Ex.:
    .querySelector('.className')
    .querySelector('#someID')
    .querySelector('h3')
    .querySelector('section>h3')
    .querySelector('div p')
    .querySelector('p:last-child')
   </notes>
   <div class='article_bar accent_1'>Nodes</div>
   <notes>
   - DOM object.
   - Accessing a DOM element will return a node or a node list.
      - not arrays. array-like. support indexing[] and forEach
         - just use [].call if you want to use an array method (see entry)
   - check what type using:
       node.nodeType;
       // Return codes and meanings:
         Code   Type
         1      element
         2      attribute
         3      text
         8      comment
         9      document
      </notes>
      <note class='accent_2'>Handy DOM methods that return lists of a Node type</note>
   <notes>
 - Handy DOM methods that return lists of a type:
    document.body
            .images
            .links
            .anchors
            .forms
      - return empty lists if !found.
      - to access actual elements from lists:
         linksList[0]
   </notes>
   <note class='accent_1'>node.children</note> & <note class='accent_2'>node.childNodes</note>
   <notes>
      - node.children returns only element nodes
         - node.childNodes returns all nodes, including whitespace n crap.
         - Similarly:
         <note class='accent_1'>.firstChild</note><note class='accent_2'>.firstElementChild</note> 
         <note class='accent_1'>.lastChild</note><note class='accent_2'>.lastElementChild</note>
         <note class='accent_1'>.next|previousSibling</note><note class='accent_2'>.next|previousElementSibling</note>
   </notes>
         <div class='article_bar accent_1'>Accessing Text & Classes</div>
         <notes>
<note class="accent_1">Text:</note>
   .textContent (best way)
   .innerHTML
   .innerText
<note class="accent_1">Classes</note>
   <note class="accent_2">(Can't use 'class')</note>
   .className // but don't use this with set/getAttribute()
   .classList
      .classList.add()
                .remove()
                .toggle() // adds if not there, removes if it is.
<note class="accent_1">Node CSS</note>
   - Every node has a style attribute property
   - CSS property names containing dashes '-' are written in camelCase:
      Ex.: padding-bottom
            node.style.paddingBottom = '1rem';
   - To access external css file properties (not inline):
      styles = getComputedStyle(NodeReference)
      // Returns everything as a READONLY CSSStyleDeclaration obj
      styles.getPropertyCSSValue('paddingBottom');
      // OR JUST ACCESS THEM LIKE SO (These seem RW):
      Node.style.propertyName

<note class="accent_2">MANIPULATING NODES</note>
INSERT BEFORE (no insertAfter)
- element.insertBefore(newChild, existingChildToBePreempted)
   // this can be used to move existing elements around
   // the html "markup."
   // this is also true with <note class="accent_2">.appendChild()</note>
   // You need to copy elements with .clone the append & insert
   // methods won't copy, that's why they move.
REMOVING
- parentNode.RemoveChild('name') returns ref to removed node.
   // using reference node can be inserted or appended
REPLACING
- parentNode.replaceChild(newNode, oldNode);
CREATE
- document.createElement('typeofelement');
INNERHTML(!caution don't use with user input!)
- innerHTML not part of official DOM; supported by all browsers.
- can replace all existing childnodes with n+ new nodes :
<div class="code-pre">
parentNode.innerHTML = `&lt;article&gt;
                        &lt;div&gt;will replace&lt;/div&gt;
                        &lt;div&gt;and create all&lt;/div&gt;
                        &lt;div&gt;nodes implied by&lt;/div&gt;
                        &lt;div&gt;supplied HTML. &lt;/div&gt;
                        &lt;/article&gt;`;
   </div>
<note class="accent_2">LIVE COLLECTIONS</note>
<div class="explanation">
   getElementBy friends:
   document.getElementsByClassName('wrapper')
   document.getElementsByTagName('div')
</div>
   - these do not take selector arguments
   - updates will be reflected live or instantly
   - handy BUT will tax performance!

<note class="accent_1 big">Try It: Manipulate the DOM </note>

      Add a &lt;note &gt; tag around main:<button class='btn' id='format'>Add note tag</button>

</notes>
</article>         
</section>
<section>
   <h3>
      + OOP IN JS
   </h3>
   <article>
<div class='article_bar accent_2'>Object Oriented Programming in JS/ES6</div>
<notes>
Starting with ES6, JS embraced OOP a bit more with classes:
   <note>(example inspired by<a href='https://www.sitepoint.com/object-oriented-javascript-deep-dive-es6-classes/'>Jeff Mott @ Sitepoint</a>)</note>
   <div class="code-pre">
<note class="accent_1">//note the keyword "class"</note>
class SimpleDate {
<note class="accent_1">// actual constructor</note>
   constructor(year, month, day) {
      <note class="accent_1">// simple validation.</note>
      <note class="accent_1">// Notice the use of "this" and "_" for private (not enforceable)</note>
      if(this.checkYear(year))
         this._year = year;
      else
         this._year = new Date().getFullYear();
      if(this.checkMonth(month))
         this._month = month;
      else
         this._month = new Date().getMonth() + 1;
      if(this.checkDay(day))
         this._day = day;
      else
         this._day = new Date().getDate();
   }

   addDays(nDays) {
      <note class="accent_1">// quick and dirty =/</note>
      <note>// ...</note>
      let newDay = 0;
      newDay = nDays + this._day;
      if (newDay % 31 !== newDay) {
         this.addMonths(parseInt(newDay/31));
         this._day = newDay % 31;
      } else {
         this._day = newDay;
      }
   }

   addMonths(nMonths) {
      <note class="accent_1">// quick and dirty =/</note>
      let newMonth = 0;
      newMonth = nMonths + this._month;
      if (newMonth % 12 != newMonth) {
         this.addYears(parseInt(newMonth/12));
         this._month = newMonth % 12;
      } else {
         this._month = newMonth;
      }
   }

   addYears(nYears) {
      this._year += nYears;
   }

   getDay() {
      return this._day;
   }

   checkYear(year) {
      return (parseInt(year) > 0);
   }

   checkMonth(month) {
      return (0 < parseInt(month) && parseInt(month) < 13);
   }
   checkDay(day) {
      <note class="accent_1">// going easy here. Allowing 1-31 for now</note>
      return (0 < parseInt(day) && parseInt(day) < 32);
   }
}

<note class="accent_1">// "today" is guaranteed to be valid and fully initialized</note>
const today = new SimpleDate();
const tomorrow = new SimpleDate(today._year, today._month, today._day+1);
</div><div class="explanation">
A few notes about encapsulation and abstraction here:
   - As shown above, the class doesn't provide for 
     real encapsulation.
   + There are some workarounds:
      - [all these workarounds makes one pine for Python]
      - Privileged Methods:
         define class method INSIDE the constructor
      - Symbols:
         using new Symbol() datatype to declare private propteries.
         - Problem is Object.getOwnPropertySymbols() provides 
           access to Symbols =(
      - and one more...</div></notes><div class='article_bar big accent_2'>WeakMaps:</div>
<notes>are a new ES6 datatype key value pairs, like a dictionary or map...
Use new WeakMap() to declare the properties, using the instance as a key, all within a closure (see next <a href="../week05/index.html">week's discussion</a>  on closures):
<div class="code-pre">
const SimpleClass = (function() {
   const _property = new WeakMap();
   class SimpleClass {
      constructor(property) {
         _property.set(this, property);
      }
      simpleAdd(addToProperty) {
         _property.set(this, (_property.get(this) + addToProperty));
      }
      getProperty() {
         return _property.get(this);
      }
   }
   return SimpleClass;
}());
</div><note>Though convoluted, this works nicely. Try to get at the property except through the class methods. It seems roped off appropriately.</note>

<note class="accent_2 big">Try it: </note> A SimpleDate and a SimpleClass are available to poke around with in the console:
   <note class="accent_1 big">SimpleDate instance:   </note>     <code class="accent_2 big"> today  </code>
   <note class="accent_1 big">SimpleClass instance:  </note>     <code class="accent_2 big"> simple </code>

<div class='explanation'>We'll continue to explore the JS/ES6 OOP implementation next week.</div>
</notes>
   </article>
         <section style="display:none">
            <h3>
               - Functional Programming
            </h3>
            <article>
               <div class='article_bar accent_2'>Where functions beget functions</div>
               </div>
               <notes>

               </notes>
            </article>         
         </section>
         <section>
            <h3>
               + Team Activity
            </h3>
            <article>
               <div class='article_bar accent_1'>TIC-TAC-TOE(bler)</div>
               </div>
               <notes>
<note class='accent_2'>Task: </note> 1 Hour to build a working tic-tac-toe game. We each came to the table with some ideas. After talking it out as a group, here's what I came up with:

<a href="team.html">Team Activity Week 4</a>

<note class="accent_1">Fun Take Away â€” print a number as binary: </note>
     <code class="accent_2"> (11).toString(2); </code> 
     '1011'  <note class="accent_1 small"> It's the 2. </note> <note class="accent small"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toString">more info</a> </note>

</notes>
            </article>         
         </section>         
         <section style="display:none">
            <h3>
               - Example Template
            </h3>
            <article>
   <div class='article_bar accent_1'>Gray on blue for less pressing sub-topic header</div>
   <!--notes are 'pre' white-spaced meaning spaces and CR's matter!!-->
   <notes>
   Body:
      <code class='big'>Try to follow the spacing</code> 
      <code class='big'>Looks better()</code>
   
   <note class='accent_2'>HOWEVER </note>, nothing in stone!
   
   <note class='accent_1'>EXPLORE </note>: that's what this is about.
   
   <div class='code'>
      code samples go here
   </div><button class='btn_swap'>swap background and text colors</button>
   
   </notes>
   <div class='article_bar accent_2'> Pressing and relevant subtopics</div>
   <notes><note>(Any attributions here)</note>
   
   Keep it to the basics. List are great.
   1. step or 
   2. meaty point
      &mdash; sub meaty point 
      &mdash; sub meaty point 
         Ex.: <code>keep in code short</code>
   3. and more...
   4. listener fires a function.
   
   Ex.:   
      </notes>
   <div class="code-pre">try {
      //to finish with a code sample
      // keep the closing div tight after cuz
      // of the pre white-space
   }</div>
            </article>         
         </section>
   </main>
   <footer>
      &copy;2020 | Mark Tobler Portfolio | WDD 330
   </footer>
</body>


</html>